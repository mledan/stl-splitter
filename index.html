<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STL Splitter for 3D Printing</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #viewer { width: 800px; height: 600px; border: 1px solid #ccc; }
        input, button { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>STL Splitter for Large Flat Models</h1>
    <p>Upload your STL file, enter printer X-Y sizes (in mm), and split into printable segments.</p>
    
    <input type="file" id="stlUpload" accept=".stl">
    <br>
    <label>Printer Max X (mm): <input type="number" id="maxX" value="200"></label>
    <br>
    <label>Printer Max Y (mm): <input type="number" id="maxY" value="200"></label>
    <br>
    <button id="processBtn">Process and Split</button>
    
    <div id="viewer"></div>
    
    <div id="status"></div>
    <div id="downloadLinks"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { STLEXporter } from 'three/addons/exporters/STLExporter.js';
        import { CSG } from 'https://unpkg.com/@gkjohnson/three-bvh-csg@0.0.14/build/index.module.js?module';
        import * as BVH from 'https://unpkg.com/three-mesh-bvh@0.7.8/build/index.module.js?module';

        // Setup viewer
        const container = document.getElementById('viewer');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        scene.add(new THREE.AxesHelper(100));
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        scene.add(new THREE.DirectionalLight(0xffffff, 0.5));

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Main processing
        const processBtn = document.getElementById('processBtn');
        processBtn.addEventListener('click', async () => {
            const file = document.getElementById('stlUpload').files[0];
            if (!file) return alert('Upload an STL file');

            const maxX = parseFloat(document.getElementById('maxX').value);
            const maxY = parseFloat(document.getElementById('maxY').value);
            if (isNaN(maxX) || isNaN(maxY)) return alert('Enter valid printer sizes');

            const status = document.getElementById('status');
            status.textContent = 'Loading STL...';

            const loader = new STLLoader();
            const geometry = await new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(loader.parse(e.target.result));
                reader.readAsArrayBuffer(file);
            });

            // Normalize and get bounding box
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const sizeX = bbox.max.x - bbox.min.x;
            const sizeY = bbox.max.y - bbox.min.y;
            const sizeZ = bbox.max.z - bbox.min.z;

            if (sizeZ > 0.1 * Math.max(sizeX, sizeY)) {
                console.warn('Model may not be flat enough');
            }

            camera.position.set(bbox.max.x, bbox.max.y, Math.max(sizeX, sizeY, sizeZ) * 2);
            camera.lookAt(0, 0, 0);

            // Display original
            scene.children = scene.children.filter(child => !child.userData.isMesh);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData.isMesh = true;
            scene.add(mesh);

            if (sizeX <= maxX && sizeY <= maxY) {
                status.textContent = 'Model fits printer - no split needed';
                provideDownload(geometry, 'original.stl');
                return;
            }

            status.textContent = 'Splitting...';

            // Determine segments
            const numX = Math.ceil(sizeX / maxX);
            const numY = Math.ceil(sizeY / maxY);
            const stepX = sizeX / numX;
            const stepY = sizeY / numY;

            const subGeometries = [];

            // For flat models, we use CSG intersect with boxes
            const evaluator = new CSG.Evaluator();
            evaluator.attributes = null; // For performance

            const baseBrush = CSG.fromGeometry(geometry);

            for (let i = 0; i < numX; i++) {
                for (let j = 0; j < numY; j++) {
                    const minX = bbox.min.x + i * stepX - 1; // Small overlap
                    const maxX = bbox.min.x + (i + 1) * stepX + 1;
                    const minY = bbox.min.y + j * stepY - 1;
                    const maxY = bbox.min.y + (j + 1) * stepY + 1;

                    const boxGeo = new THREE.BoxGeometry(maxX - minX, maxY - minY, sizeZ + 10);
                    boxGeo.translate((minX + maxX) / 2, (minY + maxY) / 2, (bbox.min.z + bbox.max.z) / 2);
                    const boxBrush = CSG.fromGeometry(boxGeo);

                    const resultBrush = evaluator.evaluate(baseBrush, boxBrush, CSG.INTERSECT);
                    const resultGeo = CSG.toGeometry(resultBrush);

                    subGeometries.push({ geo: resultGeo, i, j });
                }
            }

            // Add connectors (simple pins on edges)
            status.textContent = 'Adding connectors...';
            addConnectors(subGeometries, bbox, stepX, stepY, evaluator);

            // Export
            status.textContent = 'Exporting...';
            const exporter = new STLEXporter();
            const linksDiv = document.getElementById('downloadLinks');
            linksDiv.innerHTML = '';

            subGeometries.forEach(({ geo }, index) => {
                const stlString = exporter.parse(new THREE.Mesh(geo));
                provideDownload(stlString, `segment_${index + 1}.stl`, true);
            });

            // Assembly guide
            const guide = generateAssemblyGuide(numX, numY);
            provideDownload(guide, 'assembly_guide.txt', false);

            status.textContent = 'Done! Download segments below.';
        });

        function addConnectors(subGeometries, bbox, stepX, stepY, evaluator) {
            // Simple: Add cylinders as pins on right and top edges for adjacent pieces
            const pinRadius = 2.5; // 5mm diameter
            const pinHeight = 5;

            subGeometries.forEach(({ geo, i, j }) => {
                // Add pins on right (X) if not last in row
                if (i < Math.ceil((bbox.max.x - bbox.min.x) / stepX) - 1) {
                    // Find adjacent right: i+1, j
                    const adj = subGeometries.find(s => s.i === i+1 && s.j === j);
                    if (adj) {
                        // Add pin to this, subtract from adj
                        const pinGeo = new THREE.CylinderGeometry(pinRadius, pinRadius, pinHeight, 16);
                        pinGeo.rotateZ(Math.PI / 2); // Align along X
                        // Position: e.g., at center of shared face, multiple if large
                        // For simplicity, one at center
                        const sharedX = bbox.min.x + (i + 1) * stepX;
                        const centerY = (geo.boundingBox.min.y + geo.boundingBox.max.y) / 2;
                        const centerZ = (geo.boundingBox.min.z + geo.boundingBox.max.z) / 2;
                        pinGeo.translate(sharedX, centerY, centerZ);

                        const pinBrush = CSG.fromGeometry(pinGeo);
                        const thisBrush = CSG.fromGeometry(geo);
                        const newThis = evaluator.evaluate(thisBrush, pinBrush, CSG.UNION);
                        geo = CSG.toGeometry(newThis);

                        const adjBrush = CSG.fromGeometry(adj.geo);
                        const newAdj = evaluator.evaluate(adjBrush, pinBrush, CSG.SUBTRACT);
                        adj.geo = CSG.toGeometry(newAdj);
                    }
                }

                // Similarly for Y (top)
                if (j < Math.ceil((bbox.max.y - bbox.min.y) / stepY) - 1) {
                    const adj = subGeometries.find(s => s.i === i && s.j === j+1);
                    if (adj) {
                        const pinGeo = new THREE.CylinderGeometry(pinRadius, pinRadius, pinHeight, 16);
                        pinGeo.rotateX(Math.PI / 2); // Align along Y
                        const sharedY = bbox.min.y + (j + 1) * stepY;
                        const centerX = (geo.boundingBox.min.x + geo.boundingBox.max.x) / 2;
                        const centerZ = (geo.boundingBox.min.z + geo.boundingBox.max.z) / 2;
                        pinGeo.translate(centerX, sharedY, centerZ);

                        const pinBrush = CSG.fromGeometry(pinGeo);
                        const thisBrush = CSG.fromGeometry(geo);
                        const newThis = evaluator.evaluate(thisBrush, pinBrush, CSG.UNION);
                        geo = CSG.toGeometry(newThis);

                        const adjBrush = CSG.fromGeometry(adj.geo);
                        const newAdj = evaluator.evaluate(adjBrush, pinBrush, CSG.SUBTRACT);
                        adj.geo = CSG.toGeometry(newAdj);
                    }
                }
            });
        }

        function generateAssemblyGuide(numX, numY) {
            let guide = 'Assembly Guide:\n';
            guide += `Grid: ${numX} x ${numY}\n`;
            guide += 'Attach segments using pins:\n';
            for (let i = 0; i < numX; i++) {
                for (let j = 0; j < numY; j++) {
                    const index = i * numY + j + 1;
                    guide += `Segment ${index} at position (${i},${j})\n`;
                }
            }
            guide += 'Align pins into holes on adjacent pieces.';
            return guide;
        }

        function provideDownload(data, filename, isBinary = false) {
            const blob = isBinary ? new Blob([data], { type: 'application/octet-stream' }) : new Blob([data], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.textContent = `Download ${filename}`;
            document.getElementById('downloadLinks').appendChild(a);
            a.appendChild(document.createElement('br'));
        }
    </script>
</body>
</html>
